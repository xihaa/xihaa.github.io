# 前端面试大集合

## 自我介绍

## js相关
### 怎么学习的js

首先我刚开始学习时候从html，css开始做了一些简单的静态页面，由于静态页面太局限为了想向动态发展，针对页面要求去网上找了教程通过本地写json用js实现了分页，搜索，切换等功能。同时买了红宝书发现特别到后面理解很困难，在阮一峰和csdn上系统的学习js。

### js基本数据类型

！6种-number、string、boolen、undefined、null+ symbol

**es6新增的数据类型**

 symbol-基本类型

- number

- string

- boolen

- undefined

  函数没有返回值时，默认返回undefined

  undefined不能转换成true/false还是undefined

- null

  if（undefined==null）返回true

  if  (null===undefined) 返回false

- symbol

  参考链接. [掘金](https://juejin.im/post/5e0ea4c0f265da5d3a58ee66) (更接近面试易懂)  [阮一峰es6](https://es6.ruanyifeng.com/?search=%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B&x=0&y=0#docs/symbol) （全面）

  1. 目的
  
  保证每个属性的名字都是独一无二的就好了，这样就从根本上**防止属性名的冲突**。
  
  `（其实就是类似string的东西！用来设置对象的属性为了避免属性名重复，a[mySymbol]='s' 不能用new）`
```
let s1 = Symbol('s1'); // => Symbol(s1)
let s2 = Symbol('s2'); // => Symbol(s2)
let s3 = Symbol('s1'); // => Symbol(s1)
s1 == s3 // => false
s1 === s3 // => false    //这点也可做佐证symbol是独一无二的，就算实例描述相同
s.toString(); // => Symbol(s)
```

​		2. 写法


```
let s = Symbol();
// 第一种写法
let obj = {
    [s]: 'hello Symbol'
}

// 第二种写法
let obj = {};
obj[s] = 'hello Symbol'

// 第三种写法
let obj = {};
Object.defineProperty(obj,s,{value:'hello Symbol'})

// 以上三种写法的结果都是
obj[s]; // => hello Symbol
```

​	3. Symbol 作为属性名，遍历对象的时候，该属性不会出现在for...in、for...of循环中，也不会被Object.keys()、Object.getOwnPropertyNames()、JSON.stringify()返回。对象提供了一个`Object.getOwnPropertySymbols()`方法用于获取对象内所有Symbol属性名，返回一个数组

​	4. 当希望使用同一个Symbol值时

```
let s1 = Symbol.for('s');
let s2 = Symbol.for('s');
s1 === s2; // => true
```

### js复杂类型（引用类型）

object+**es6新增** Set、WeakSet、map、WeakMap

#### object
- 狭义对象object
- 数组array
- 函数function
- Set 
- WeakSet
- Map
- WeakMap

#### set

**Set对象里面只要有重复的值他都会只保留一个，无论是原始值还是对象引用。**

<img src="/Users/xihaa/Library/Application Support/typora-user-images/image-20200325005148504.png" alt="image-20200325005148504" style="zoom: 50%;" />

- 作用：给数组去重

<img src="/Users/xihaa/Library/Application Support/typora-user-images/image-20200325005458059.png" alt="image-20200325005458059" style="zoom:50%;" />

Array.from()用来将set对象转换成数组

或者

```javascript
let arr = [3, 5, 2, 2, 5, 5];
let unique = [...new Set(arr)];
// [3, 5, 2]
```

#### WeakSet

WeakSet 结构与 Set 类似，也是不重复的值的集合。但是，它与 Set 有两个区别。

首先，WeakSet 的成员只能是对象，而不能是其他类型的值。

##### 1. WeakSet 的成员只能是对象，而不能是其他类型的值

##### 2. WeakSet 中的对象都是弱引用

垃圾回收机制不考虑 WeakSet 对该对象的引用，也就是说，如果其他对象都不再引用该对象，那么垃圾回收机制会自动回收该对象所占用的内存，不考虑该对象还存在于 WeakSet 之中

> 弱引用：如果其他对象都不再引用该对象，那么垃圾回收机制会自动回收该对象所占用的内存，不考虑该对象是否还在该弱引用的结构中。
注意： 弱引用的对象不可遍历！

#### Map

JavaScript 的对象（Object），本质上是键值对的集合（Hash 结构），它类似于对象，也是键值对的集合，但是“键”的范围不限于字符串，**各种类型的值（包括对象）都可以当作键**。

也就是说，**Object** 结构提供了“**字符串—值**”的对应，**Map 结构**提供了“**值—值**”的对应，是一种更完善的 Hash 结构实现。

```javascript
const m = new Map();
const o = {p: 'Hello World'};

m.set(o, 'content')
m.get(o) // "content

const map = new Map([
  ['name', '张三'],
  ['title', 'Author']
]);
map.size // 2
map.has('name') // true
map.get('name') // "张三"
map.has('title') // true
map.get('title') // "Author"
```

- 常用属性和操作方法

  m.size()            m.has()

  m.set() 返回map对象所以可以链式调用         m.get()         

  m.delete()        m.clear()

- 遍历方法

  - `Map.prototype.keys()`：返回键名的遍历器。
  - `Map.prototype.values()`：返回键值的遍历器。
  - `Map.prototype.entries()`：返回所有成员的遍历器。
  - `Map.prototype.forEach()`：遍历 Map 的所有成员。

- map与其他类型互换

  - 与数组互换

  <img src="/Users/xihaa/Library/Application Support/typora-user-images/image-20200325013950593.png" alt="image-20200325013950593" style="zoom: 33%;" />

<img src="/Users/xihaa/Library/Application Support/typora-user-images/image-20200325014311705.png" alt="image-20200325014311705" style="zoom:33%;" />

#### WeakMap

##### 1. WeakMap只接受对象作为键名，不接受其他类型的值作为键名

##### 2. WeakMap弱引用的键名所指向的对象，不计入垃圾回收机制


#### 类型判断

- typeof操作符

  可鉴别**6**种


  可返回number、string、boolean、函数function、undefined（typeof可以检查一个未声明的变量而不报错而是返回undefined）、对象object（数组、对象、**null都返回object**）

### Proxy-代理器

Proxy 可以理解成，在目标对象之前架设一层“拦截”，外界对该对象的访问，都必须先通过这层拦截，因此提供了一种机制，可以对外界的访问进行过滤和改写。

```javascript
var proxy = new Proxy(target, handler);
```

Proxy 对象的所有用法，都是上面这种形式，不同的只是`handler`参数的写法。其中，`new Proxy()`表示生成一个`Proxy`实例，`target`参数表示所要拦截的目标对象，`handler`参数也是一个对象，用来定制拦截行为。

Proxy 提供虚拟化接口来控制任何目标 Object的行为。 这样做可以在简单性和实用性之间取得平衡，而不会牺牲兼容性。

Vue3.0 中将会通过 `Proxy` 来替换原本的 `Object.defineProperty` 来实现数据响应式。

### 闭包

- 概念


**闭包函数：**声明在一个函数中的函数，叫做闭包函数。

**闭包：**内部函数总是可以访问其所在的外部函数中声明的参数和变量，即使在其外部函数被返回（寿命终结）了之后。

- 特点

 让外部访问函数内部变量成为可能；

 局部变量会常驻在内存中；

 可以避免使用全局变量，防止全局变量污染；

 会造成内存泄漏（有一块内存空间被长期占用，而不被释放）

- 闭包的应用场景

 **结论：闭包找到的是同一地址中父级函数中对应变量最终的值**
```
function outerFn(){
  var i = 0; 
  function innerFn(){
      i++;
      console.log(i);
  }
  return innerFn;
}
var inner = outerFn();  //每次外部函数执行的时候，外部函数的地址不同，都会重新创建一个新的地址
inner();
inner();
inner();
var inner2 = outerFn();
inner2();
inner2();
inner2();   //1 2 3 1 2 3
```
```
function fn(){
	var a = 3;
	return function(){
		return  ++a;                                     
	}
}
alert(fn()());  //4
alert(fn()());  //4  

var add = function(x) { 
  var sum = 1; 
  var tmp = function(x) { 
      sum = sum + x; 
      return tmp;    
  } 
  tmp.toString = function() { 
      return sum; 
  }
  return tmp; 
} 
alert(add(1)(2)(3));     //6
```
```
for (var i=1;i<=5;i++){
	setTimeout(function timer() {
		console.log(i)
	},i*1000)
}
//输出6
正常情况下，我们对这段代码的预期是每隔一秒输出一个数字，1-5。但是实际上并不会这样，这段代码会每间隔一秒输出一个数字6。这是为什么？

首先6从哪里来，当timer执行时，for循环早已结束，终止条件是i=6。
有些小伙伴可能会不明白了，timer不是创建了闭包，保持了对i的引用吗？
没错。for循环了5次，创建了5个闭包，但是都是保持了对同一个i的引用（i是全局变量）。所以当timer执行时，i = 6，输出6，没毛病。
那么如何达到我们想要的效果，我们需要更多的闭包。循环过程中每个迭代都需要一个闭包
for (var i=1;i<=5;i++){
	(function(j){
		setTimeout(function timer() {
			console.log(j)
		},j*1000)
	})(i)
}
立即执行函数创建了一个新的作用域，使得延迟函数的的回调可以将新的作用域封闭在每个迭代内部。
```
### js反转字符串

```
//方法一：转数组反转之后再转回字符串
function reverse(str) {
    return str.split('').reverse().join('');
}
//存在的问题：
�的 Unicode 码点是+UFFFD，通常用来表示 Unicode 转换时无法识别的字符（也就是乱码）
当💩（\uD83D\uDCA9）通过上述方法反转时，变成\uDCA9\uD83D，不是一个合法的代理对（高低字节范围不同），同时，Unicode 规定代理对范围内的码点不能单独出现，所以 js 只能用�表示了。
reverse('这是一坨💩')
"��坨一是这"
//方法二：ES6 的 Array.from 支持代理对的解析
function reverse(string) {
	return Array.from(string).reverse().join('');
}
```

### 数组去重合并

```
function combine(){ 
    let arr = [].concat.apply([], arguments);  //没有去重复的新数组 
    return Array.from(new Set(arr));
} 

var m = [1, 2, 2], n = [2,3,3]; 
console.log(combine(m,n));    
```

### js数字

JS中的数字是用[IEEE 754 双精度 64 位浮点数](http://en.wikipedia.org/wiki/Floating_point#Internal_representation)来存储的，它由64位组成，这64位由3部分组成，（S：符号位，Exponent:指数域，Fraction：尾数域）。

### es6 map和对象object的区别

object和Map存储的都是键值对组合。

1. Object的键类型是简单数据类型（整数，字符串或者是 symbol），Map的键类型可以是任何类型（真正意义上的值-值）

   ```
   //当key值是整数时- JS 会隐式地将对象的键转换为字符串
   const names = {
     1: 'One',
     2: 'Two',
   };
   
   Object.keys(names); // => ['1', '2']
   复制代码
   ```

   JS 会隐式地将对象的键转换为字符串

2. 键值对的个数

   想要知道键值对的个数Map直接用map.size；但是object对象只能手动去数，或者借助Object.keys(obj).length

3. **元素顺序**

   Map 元素的顺序遵循插入的顺序，而 Object 的则没有这一特性。即如果遍历对象则输出的顺序并不一定是当时构造的顺序

4. 新建实例

   Object 支持以下几种方法来创建新的实例：

   ```
   var obj = {...};
   var obj = new Object();
   var obj = Object.create(null);
   ```

   Map 构建方法：

   ```
   var map = new Map([
             [1, 2], [2, 3]
             ]); // map = {1 => 2, 2 => 3}
   ```

5. 数据访问

   ```
   //map通过自身的函数
   map.get(1) // 2
   ```

   ```
   //object
   obj.id;
   obj['id'];
   let obj={1:'s','t':'d'}
   obj.1//错误❌
   obj[1]
   obj[t]//错误❌
   obj.t obj['t']
   ```

   判断某个元素是否在 Map 中可以使用

   ```
   map.has(1);
   ```

   判断某个元素是不是在 Object 中需要以下操作：

   ```
   obj.id === undefined;
   // 或者
   'id' in obj;
   ```

6. 删除数据

   在 Object 中没有原生的删除方法，我们可以使用如下方式：

   ```
   delete obj.id;
   
   // 下面这种做法效率更高
   
   obj.id = undefined
   //
   需要注意的是，使用 delete 会真正的将属性从对象中删除，而使用赋值 undefined 的方式，仅仅是值变成了 undefined。属性仍然在对象上，也就意味着 在使用 for… in… 去遍历的时候，仍然会访问到该属性。　　
   ```

   Map 有原生的 delete 方法来删除元素：

   ```
   var isDeleteSucceeded = map.delete(1);
   
   console.log(isDeleteSucceeded ); // true
   
   // 全部删除
   
   map.clear();
   ```

7. 迭代

   

### js中的this

[**参考链接：关于 this 的解释说明**](https://www.yuque.com/fe9/basic/utskuy#5nlous)

【**有。 关    函    数**】

【**函数 this 的指向取决于当前调用该函数的对象，也就是执行时的对象。**】

【**当前执行上下文的 ThisBinding 的值就是 this。this 是执行上下文的一个属性**。**也可以把 this 称为上下文对象**】

【 **this 始终会指向直接调用函数的上一级对象**。】

它其实是一个对象，它可以是全局对象、当前对象，或者任意对象，函数的调用方式决定了 this 的值。

`this` 在**未执行**时我们谁也不知道它的指向到底是谁，因为**只有函数被调用时**才会对 `this` 进行赋值。**函数 this** 的指向取决于**当前调用该函数的对象**，也就是**执行时的对象**。

当前执行上下文的 ThisBinding 的值就是 this。 this 是一个对象，**与执行的上下文环境息息相关**，也可以把 this 称为上下文对象，激活执行上下文的上下文。

#### 情况总结

- 全局执行上下文—指向全局对象
- 作为对象的方法调用

#### 全局执行上下文

在全局环境中 **this指向全局对象**，浏览器中是Windows。node中是global

```
var x = 1

console.log(this.x)               // 1
console.log(this.x === x)         // true
console.log(this === window)      // true
```

##### 函数在全局中被调用

当一个函数并非一个对象的属性时，那么它就是被当做一个函数来调用的。此时，相当于在全局上下文环境中调用此函数，this 指向全局对象 。同时与作用域问题相结合，在函数内部不用this调用变量，输出的还是作用域链的变量

```
//1-全局中调用
var funA = function() {
  return this.value;
}
console.log(funA()); //undefined
var value = 233;
console.log(funA()); //233

//2-与作用域情况相结合(！自创好例子！)
var x=1;
function f1(){  
    var x=2;
    console.log(this.x);//1
    console.log(x);//2
    f2(); //这里注意因为f2是在全局中定义的，所以f2中变量是全局的@@这里有点疑惑@@
    {
    	console.log(x);//2 //可以访问上层作用域变量
    }
    f3();
    function f3(){  //这里注意f3是在f1中定义的
    	console.log(this.x);//1
    	console.log(x);//2
    }
}
function f2(){
    console.log(this.x);//1
    console.log(x);//1
}
f1();
//1 2 1 1 2 1 2 1 1
```

**严格模式下的函数在全局中调用**

使用严格模式，只需要将 'use strict' 置于函数体的顶部。这样上下文环境中的 this 将为 undefined。

```
function strictFun() {  
    'use strict';
    console.log(this === undefined); // => true
}
```

#### 作为对象的方法调用

##### 函数作为**某个对象的方法**调用

当函数作为**某个对象的方法**调用时，***this 指向该对象***。值得注意的是，如果将**函数赋值给某个变量，并没有立即执行**，this 的值就要根据函数执行时所在的环境对象进行判断。

```
var x = 1
var obj = {
    x: 2,
    getX: function() {
        console.log(this.x)
    }
}
obj.getX()     // 2
//函数作为某个对象的方法调用，发起者是obj对象

var a = obj.getX
a()            // 1 
//这里把函数复制给了a变量，但是a变量是在全局上下文中执行的，所以this指向全局变量
```

##### 函数被多个**对象**嵌套调用

如果函数被多个**对象嵌套**调用，**this 始终会指向直接调用函数的上一级对象**。这里要注意是上一级**对象**，是在对象嵌套的情况下

```
var x = 1
var obj = {
  x: 2,
  y: {
    x: 3,
    getX: function() {
    	console.log(x) // 1 因为实在全局中调用
      console.log(this.x)
    }
  }
}

obj.y.getX()      // 3
//这里虽然发起者是obj对象，但是 this 始终会指向直接调用函数的上一级对象，即 y。
```

##### 函数嵌套后调用

**嵌套的函数**不会从**调用它的函数中继承 this**，当嵌套函数作为函数调用时，其 this 值在非严格模式下指向全局对象，在严格模式是 undefined。

```
var obj = {
    y: function() {
        console.log(this === obj)
        getX() //这里自己的理解是——函数会进行声明提升，这也是一个普通的函数。这时候this指向window全局对象
				
        function getX() {
            console.log(this === obj)
            console.log(this)
        }
    }
}

obj.y()  
// true
// false
// 全局对象
//函数
```

#### 作为构造函数调用

我们可以使用 new 关键字，通过构造函数生成一个实例对象。此时，**this 便指向这个新对象。**

```
var x = 1

function Demo() {
  this.x = 2
}

var a = new Demo()

console.log(a.x)    // 2
```

值得一提的是，如果构造函数返回了一个对象，this 便会指向返回的对象，如果构造函数返回了非引用类型（string，number，boolean，null，undefined），this 仍然指向实例化的新对象。

```
var x = 1

function Demo() {
  this.x = 2
  return {
    x: 3
  }
}

var a = new Demo()

console.log(a.x)      // 3


var x = 1

function Demo() {
  this.x = 2

  return 3
}

var a = new Demo()

console.log(a.x)      // 2
```

#### 使用 call 和 apply

如果你想改变 this 的指向，可以使用 call 或 apply 方法，它们都可以改变函数的调用对象。将一个对象作为第一个参数传给 call 或 apply，this 便会绑定到这个对象。如果第一个参数不传或者传 null 、undefined，默认 this 指向全局对象（非严格模式）或 undefined（严格模式）。

```
var x = 1;

var obj = {
  x: 2
}

function getX() {
  console.log(this.x)
}

getX.call(obj)      // 2
getX.apply(obj)     // 2

getX.call()         // 1
getX.apply(null)    // 1
getX.call(undefined)    // 1
```



使用 call 和 apply 时，如果给 this 传的不是对象，JavaScript 会使用相关构造函数将其转化为对象，比如传 number 类型，会进行 `new Number()` 操作，传 string 类型，会进行 `new String()` 操作。



```
function demo() {
  console.log(Object.prototype.toString.call(this))
}

demo.call('hello')      // [object String]
demo.apply(5)           // [object Number]
```



call 和 apply 的区别在于，call 的第二个及后续参数是一个参数列表，apply 的第二个参数是数组。参数列表和参数数组都将作为函数的参数进行执行。



```
var x = 1
var obj = {
  x: 2
}

function getSum(y, z) {
  console.log(this.x + y + z)
}

getSum.call(obj, 3, 4)       // 9
getSum.apply(obj, [3, 4])    // 9
```

##### call/apply实现原理

<img src="/Users/xii/Library/Application Support/typora-user-images/image-20200730171802728.png" alt="image-20200730171802728" style="zoom:50%;" />

1.首先要明白call/apply是用来实现继承的！就是不用重写而且去“偷来别人的技能”

2.同时去改变函数本身的this指向，绑定到指定的传参对象。比如 吃鱼中的this指向要绑定到狗身上了 即就要 为参数`狗`创建一个 `Symbol`（保证不会重名）属性，将当前函数赋值给这个属性

3.要执行和删除此函数，即在执行 猫.吃鱼.call(狗，鱼)的时候就已经执行 吃鱼 函数了

4.如果不传参数则默认指向window

```
//call手动实现
Function.prototype.mycall=function(context=window,...args){
    if(this===Function.prototype.mycall){
        return undefined;
    }
    const fn=Symbol();
    console.log(this);
    context[fn]=this;//this应该指向当前函数
    console.log(context);
    const res=context[fn](...args);
    delete context[fn];
    return res;
}
//test
var x=1;
var obj={
    x:2
}
function getX(){
    console.log(this.x);
}
getX.mycall(obj);
//输出
//[Function: getX]
//{ x: 2, [Symbol()]: [Function: getX] }
//2
//进一步的说明了call函数的作用就是去“偷别人的技能”，来当成自己的属性

*
 apply手动实现
*
Function.prototype.myapply=function(context=window,args){
    if(this===Function.prototype){
        return undefined;
    }
    const fn=Symbol();
    context[fn]=this;
    let res;
    if(Array.isArray(args)){
        res=context[fn](...args);
    }else{
        res=context[fn]();
    }
    return res;
}

var x=1;
var obj={
    x:2
}
function getX(){
    console.log(this.x);
}
getX.myapply(obj,[3,4]);
//跟call的区别就是第二个参数为数组
```

#### bind方法

bind 方法会创建一个新函数，新函数的 this 会永久的指向 bind 传入的第一个参数。我们来看下面的列子。

```
var x = 1
var obj_1 = {
  x: 2
}
var obj_2 = {
  x: 3
}

function getX() {
  console.log(this.x)
}

var a = getX.bind(obj_1)
var b = a.bind(obj_2)

getX()           // 1
a()              // 2
b()              // 2
a.call(obj_2)    // 2
```

在上面的例子中，虽然我们尝试给函数 a 重新指定 this 的指向，但是它依旧指向第一次 bind 传入的对象，即使是使用 call 或 apply 方法也不能改变这一事实。

##### bind实现原理

- 1.处理参数，返回一个闭包
- 2.判断是否为构造函数调用，如果是则使用`new`调用当前函数
- 3.如果不是，使用`apply`，将`context`和处理好的参数传入

```
Function.prototype.mybind=function(context=window,...args1){
    if(this===Function.prototype){
        return  new TypeError('Error');
    }
    console.log(this);
    console.log(args1);
    const _this=this;
    return function F(...args2){
        console.log(this);
        // 判断是否用于构造函数
        if (this instanceof F) {
            return new _this(...args1, ...args2)
        }
        return _this.apply(context, args1.concat(args2))
    }
}
var x = 1
var obj_1 = {
  x: 2
}
var obj_2 = {
  x: 3
}

function getX() {
  console.log(this.x)
}
//一般情况
var a = getX.mybind(obj_1)

a() 
//[Function: getX]
//[]
//全局对象
//2


// 用于构造函数的情况

// function Person(name, age) {
//     this.name = name;
//     this.age = age;
//   }
  
// var _Person = Person.mybind({});
// var p=new _Person('nn',30);
//[Function: Person]
//[]
//F {}
```



#### 箭头函数

ES6 新增了箭头函数，箭头函数不仅更加整洁，还对 this 的指向进行了改进。箭头函数**会从作用域链的上一层继承 this。**

在前面函数嵌套函数的例子中，被嵌套的函数不会继承上层函数的 this，如果使用箭头函数，会发生什么变化呢？

```
var obj = {
  y: function() {
      console.log(this === obj)

      var getX = () => {
          console.log(this === obj)
      }
      getX()
  }
}

obj.y() 
// true
// true
```

和普通函数不一样，箭头函数中的 this 指向了 obj，这是因为它从上一层的函数中继承了 this，你可以理解为箭头函数修正了 this 的指向。我们再来看个例子。

```
var x = 1
var obj = {
  x: 2,
  y: function() {
      var getX = () => {
           console.log(this.x)
      }
      return getX()
  }
}

obj.y()            // 2
var a = obj.y
a()               // 1
```

如果理解了前文，这里也是很容易理解的。obj.y() 在运行时，调用它的对象是 obj，所以 y 中的 this 指向 obj，y 中的箭头函数 getX 继承了 y 中的 this，所以结果是 2。如果我们先将 y 赋值给全局作用域中的变量 a，a 在运行时，y 中的 this 便指向了全局对象，所以得到的结果是 1（非严格模式）。

同 bind 一样，箭头函数也很“顽固”，我们无法通过 call 和 apply 来改变 this 的指向。

```
var x = 1
var obj = {
  x: 2
}

var a = () => {
  console.log(this.x)
}

a.call(obj)       // 1
a.apply(obj)      // 1
```

### 执行上下文

参考链接：[**JS（八）预编译执行过程**](https://www.yuque.com/fe9/basic/ua8kmw)

【在执行代码之前，把将要用到的所有的变量都事先拿出来，有的直接赋值了，有的先用undefined占个空。】

#### JS运行三部曲

##### 第一步：**语法分析**

语法分析也叫**语义分析**，语法分析他是通篇执行的一个过程，比如我写了好多行代码，这些代码在执行的时候他是解释一行执行一行，但是在执行之前系统执行的第一步它会扫描一遍，看看有没有低级的语法错误，比如少些个符号，带个特殊字符之类的，它会通篇扫描一遍，但是不执行，这个通篇扫描的过程叫语法分析，通篇扫描之后它会预编译，然后在解释一行执行一行，也就是解释执行。

GO(Global Object全局对象===window)>AO

##### 第二步：**预编译**

- 预编译前奏

  - **imply global** 暗示全局变量: 即任何变量,如果变量未经声明就赋值,自变量就为全局对象所有
- 一切声明的全局变量,全是 `window` 的属性
  
  - eg: var a = 123; ===> window.a = 123;
- 变量声明和初始化是不一样的东西；声明会提升，初始化还是在原地初始化。所以有时候会出现var之后为undefined的情况，因为声明后的默认值就是undefined；以上是预编译环节——所以很多时候输出跟你想象的不一样很有可能是预编译环节进行了变量提升
  
  -  函数声明整体提升 变量声明-提升
- AO 是在预编译-》执行中一步步被改变的在预编译的时候已经进行函数声明提升的函数，在执行中再遇到就不会再看了
  
- 注意⚠️ 在函数里面嵌套的函数 在全局执行上下文中是不会被提升的，执行的是以下步骤
  
- 预编译正式

  - 创建AO对象

  - 找**形参**和**变量声明**,将变量和形参名作为AO属性名,值为undefined

  - 将**实参值和形参统一**

  - 在函数体里面找**函数声明**，值赋予函数体  （**这步优先级最高**）

    ```
    function test(a){ 
    	console.log(a);
      function a(){} 
    } 
    test(1); // f a(){}
    函数声明提升 优先级高
    ```

##### 第三步：**解释执行**

在这步执行的时候，如果执行到初始化的时候也是会替换掉函数声明的。


### 执行上下文和作用域的区别

[参考链接-执行上下文和作用域的理解](https://segmentfault.com/a/1190000011843356)

作用域只是一个“地盘”，其中没有变量。**变量是通过作用域对应的执行上下文环境中的变量对象来实现的**。所以作用域是静态观念的，而执行上下文环境是动态上的，两者并不一样。**有闭包存在时，一个作用域存在两个上下文环境也是有的。**

同一个作用域下，对同一个函数的不同的调用会产生不同的执行上下文环境，继而产生不同的变量的值，**所以，作用域中变量的值是在执行过程中确定的，而作用域是在函数创建时就确定的。**

**如果要查找一个作用域下某个变量的值，就需要找到这个作用域对应的执行上下文环境，再在其中找到变量的值。**

#### 执行上下文-动态

函数每调用一次，都会产生一个新的执行上下文环境。因为不同的调用可能就有不同的参数。

```
function fn(x) {
  console.log(arguments)
  console.log(x)
}
fn(20)
fn(10) // 不同的调用可能有不同的参数
```

#### 执行上下文栈

**执行全局代码**时，会产生一个执行上下文环境，每次调用函数都又会执行上下文环境。当函数调用完成时，这个上下文环境以及其中的数据都会被消除（当然了闭包并不会乖乖就范），**处于活动状态的执行上下文环境只有一个**。

> 注意：执行上下文栈是在执行中形成的

```
// 这是一个压栈出栈的过程--执行上下文栈
1 let a = 10, fn, // 1、进入全局上下文环境
2    bar = function(x) {
3      let b = 5
4      fn(x + b) // 3、进入fn函数上下文环境
5    }
6 fn = function(y) {
7  let c = 5
8  console.log(y + c)
9 }
10
11 bar(10) // 2、进入bar函数上下文环境
```

<img src="/Users/xihaa/Library/Application Support/typora-user-images/image-20200423002148876.png" alt="image-20200423002148876" style="zoom:50%;" />

#### 作用域-静态，‘地盘’

JS没有块级作用域，除了全局作用域，函数会创建自己的作用域。**作用域在函数定义时就已经确定了**，不是在函数调用确定（区别于执行上下文环境，当然this也是上下文环境里的成分）

```
// 全局作用域
let x = 100
    // fn作用域
    function fn(x) {
        // bar作用域
        function bar(x) {
          console.log(x)
        }
    }

let f1 = fn(5)
let f2 = fn(10)

f1() // 5
f2() // 10
```

#### 作用域链

函数在定义的时候（不是调用的时候）就已经确定了函数体内部自由变量的作用域。

> 自由变量：比如a，是在fn作用域使用，但是并没有在fn作用域定义，这就是自由变量。

```
let a = 100
function fn() {
  let b = 20
  function bar() {
    console.log(a + b) // a是自由变量
  }
  return bar
}

let x = fn(), b = 200
x()   
```

那么自由变量是如何得到的呢？这就引出了作用域链。

bar要取得a的值，就要到创建bar这个函数的作用域中取值（这里是fn作用域），fn作用域也没有a，就到创建fn这个函数的作用域中取值（这里是全局作用域），找到了就结束了。这就是作用域链。

### 原型和原型链

[参考链接：**原型与原型链**](https://www.yuque.com/fe9/basic/zk5e4f)

**总结**：JavaScript 也是一门面向对象的语言，在 c++ 中，我们可以知道，类是事物的抽象，通过类可以生成一个个实例化的具体对象，类提供着生成对象的“模板”。在 JavaScript 中构造函数（constructor）就起着“模板”的作用，**通过构造函数，我们可以生成实例化的对象。**每个函数都存在一个原型对象属性prototype，即原型,它也是一个对象。并且每个实例对象都有一个私有属性 ____proto__，该属性指向了这个实例对象的原型，你可以通过 ES6 的 `Object.getPrototypeOf()` 来访问该属性，____proto__指向了实例对象的原型。JavaScript 中的所有对象都来自 Object，Object 位于原型链的最顶端，几乎所有 JavaScript 的实例对象都是基于 Object。

在 JavaScript 中，如果想访问某个属性，首先会在实例对象（cat）的内部寻找，如果没找到，就会在该对象的原型（cat.__proto__，即 Cat.prototype）上找，我们知道，对象的原型也是对象，它也有原型，如果在对象的原型上也没有找到目标属性，则会在对象的原型的原型（Cat.prototype.__proto__）上寻找，以此内推，直到找到这个属性或者到达了最顶层。在原型上一层一层寻找，这便就是原型链了。

JavaScript 也是一门面向对象的语言，很神奇的是，在 ES6 之前，JavaScript 中没有 class 语法。接触过大学课程的都知道，c++ 也是面向对象的，典型的面向对象语言都是通过类来创建实例对象。在 c++ 中，我们可以知道，类是事物的抽象，通过类可以生成一个个实例化的具体对象，类提供着生成对象的“模板”。在 JavaScript 中构造函数（constructor）就起着“模板”的作用，**通过构造函数，我们可以生成实例化的对象。**

```
function Cat() {
    this.color = 'orange'
}

var cat = new Cat()
console.log(cat.color)     // orange
```

在上面的代码中，Cat 就是构造函数，使用 new 关键字来调用构造函数生成实例对象，我们约定构造函数的函数名要大写，在构造函数的内部可以使用 this 关键字来添加属性。

#### prototype

了解完了构造函数，我们来看一下与函数相关的 prototype 关键字。每个函数都有一个 prototype 属性，它其实是个对象，我们可以通过代码来看一下。

```
function Cat() {
    this.color = 'orange'
}

console.log(Cat.prototype)
```

打开 chrome 浏览器的开发者工具，在 console 栏输入上面的代码，你可以看到 Cat.prototype 的值：

![img](https://cdn.nlark.com/yuque/0/2018/png/199663/1544770142082-b906f445-80a1-4a05-a2b1-50200f85ece4.png)

（Cat.prototype 在控制台的输出结果）

#### ____proto__

在 JavaScript 中，每个实例对象都有一个私有属性 [[Prototype]]，该属性指向了这个实例对象的原型，你可以通过 ES6 的 `Object.getPrototypeOf()` 来访问该属性，许多浏览器也对 [[Prototype]] 进行了实现，也就是我们经常见到的 __proto__，没错，__proto__ 指向了实例对象的原型，它也是一个对象。



```
function Cat() {
    this.color = 'orange'
}

var cat = new Cat()
console.log(cat.__proto__)
console.log(Object.getPrototypeOf(cat) === cat.__proto__)  // true
```



![img](https://cdn.nlark.com/yuque/0/2018/png/199663/1544770142082-b906f445-80a1-4a05-a2b1-50200f85ece4.png)

（cat.__proto__ 在控制台的输出结果）

细心的你可能会发现，实例对象的 __proto__ 与创建该实例对象的构造函数的 prototype 是相等的，是的没错，构造函数的 prototype 指向调用该构造函数而创建的实例对象的原型，我们可以通过代码来看一下。

```
function Cat() {
    this.color = 'orange'
}

var cat = new Cat()

console.log(cat.__proto__ === Cat.prototype)   // true
```

#### constructor

在上文的 Cat.prototype 打印截图中，相信你已经看到了 constructor 这个字段，字段的内容是一个函数，函数名和构造函数竟然一样。可以说，每个原型对象都有一个 constructor 属性，指向相关联的构造函数，所以构造函数和构造函数的 prototype 是可以相互指向的。

```
function Cat() {
    this.color = 'orange'
}

console.log(Cat.prototype.constructor === Cat)    // true
```

<img src="https://cdn.nlark.com/yuque/0/2018/png/199663/1544775326033-e24180a5-3066-45e9-a2b7-4dfb765e33de.png" alt="img" style="zoom:50%;" />

（实例原型的 constructor 属性指向相关构造函数）

#### 原型链

在构造函数中，我并没有设置有关 age 的属性，只是把 age 设置在了实例原型上，然后我们通过实例对象也能访问到 age 属性。在 JavaScript 中，如果想访问某个属性，首先会在实例对象（cat）的内部寻找，如果没找到，就会在该对象的原型（cat.__proto__，即 Cat.prototype）上找，我们知道，对象的原型也是对象，它也有原型，如果在对象的原型上也没有找到目标属性，则会在对象的原型的原型（Cat.prototype.__proto__）上寻找，以此内推，直到找到这个属性或者到达了最顶层。在原型上一层一层寻找，这便就是原型链了。

```
function Cat() {
    this.color = 'orange'
}

Cat.prototype.age = 4

var cat = new Cat()

console.log(cat.color)    // orange
console.log(cat.age)      // 4
```

它就是 null，null 没有原型，所以 Object.prototype 就是原型链的最顶端。

可以说，JavaScript 中的所有对象都来自 Object，Object 位于原型链的最顶端，几乎所有 JavaScript 的实例对象都是基于 Object。

我们可以将图片更新一下：

<img src="/Users/xihaa/Library/Application Support/typora-user-images/image-20200424171607368.png" alt="image-20200424171607368" style="zoom:50%;" />

#### 关于继承

JavaScript 的继承是基于原型链的，在原型链的任何位置设置属性，都能被对象访问到，原型的作用也是在此，它可以包含所有实例共享的属性和方法，就像该属性本来就在实例对象上一样，与其说是继承，不如说**原型链建立了一个链条**，可以顺藤摸瓜，**实例对象可以访问这根链条上的属性和方法**。

```
function Cat() {
    this.color = 'orange'
    this.age = 4
}

Cat.prototype.getColor = function() {
    console.log(this.color)
}

Object.prototype.getAge = function() {
    console.log(this.age)
}

var cat = new Cat()
cat.getColor()       // orange
cat.getAge()        //1
//这里的this就是指向实例对象
```

基于原型链的继承其实随处可见，只是我们没有意识到。当你随手新建一个数组，是否想过它怎么会有 splice、indexOf 等方法，新建一个函数怎么可以直接使用 call 和 bind？其实数组都继承于 Array.prototype，函数都继承于 Function.prototype，它们分别包含了数组和函数的基本方法，尝试去控制台打印出 Array.prototype 和 Function.prototype，上面的疑问便可得到解答。并且 Array.prototype， Function.prototype和Object.prototype是不同的东西也不是一个原型链上的东西。

Array.prototype是一个数组而非是一个对象

函数的实例原型的__proto__是Object.prototype，但是函数的__proto__ 是Function.prototype

```
var a = ['hello', 'world']
function f() {}

console.log(a.__proto__ === Array.prototype)      // true
console.log(f.__proto__ === Function.prototype)   // true
console.log(a.__proto__ === Object.prototype)     //false
console.log( Array.prototype)								 //Array(0)[ ]
console.log( Function.prototype)			
console.log(f.prototype.__proto__ === Object.prototype)   // true

```

### js遍历对象的方法
#### for...in

```
const obj = {
            id:1,
            name:'zhangsan',
            age:18
}

 for(let key  in obj){
        console.log(key + '---' + obj[key])
  }
```
#### Object.keys（obj）  Object.values（obj）

输出相应的数组

```
console.log(Object.keys(obj))
console.log(Object.values(obj))
//输出结果： obj对象的key组成的数组
['id','name','age']
输出结果：obj对象的value组成的数组

['1','zhangsan','18']
```

#### Object.getOwnPropertyNames(obj)
返回一个数组，包含对象自身的所有属性（包含不可枚举属性）；效果与Object.keys（obj）相同
遍历可以获取key和value

```
const obj = {
            id:1,
            name:'zhangsan',
            age:18
    }
    Object.getOwnPropertyNames(obj).forEach(function(key){
        console.log(key+ '---'+obj[key])
    })
    console.log( Object.getOwnPropertyNames(obj));
```

<img src="/Users/xihaa/Library/Application Support/typora-user-images/image-20200428175037296.png" alt="image-20200428175037296" style="zoom:50%;" />

### js遍历数组的方法

#### for循环

for循环注意要使用临时变量，将长度缓存起来，避免重复获取数组长度

```
for(let j = 0,len=arr.length; j < len; j++) { }
```

#### forEach

```
//1 没有返回值
arr.forEach((item,index,array)=>{
 //执行代码
})
//参数：item数组中的当前项, index当前项的索引, array原始数组；
```

#### map

参数和foreach、filter相同，有返回，返回的新数组不会替换原数组,需要接收一个新变量存储新的数组!！

```
var ary = [12,23,24,42,1]; 
var res = ary.map(function(item,index,ary ) { 
  return item*10; 
}) 
console.log(res);//-->[120,230,240,420,10]; 原数组拷贝了一份，并进行了修改
console.log(ary);//-->[12,23,24,42,1]; 原数组并未发生变化
```

#### for...of

遍历数组的值 value

```
for(var value of myArray) {
	console.log(value);
}
```

#### filter

参数和foreach、map相同，有返回，返回的新数组不会替换原数组

```
var arr = [73,84,56, 22,100]
var newArr = arr.filter((item,index,ary) => item>80)  //得到新数组 [84, 100]
console.log(newArr,arr)
```

#### every

every()是对数组中的每一项运行给定函数，如果该函数对**每一项**返回true,则返回true。

```
var arr = [ 1, 2, 3, 4, 5, 6 ]; 
console.log( arr.every(function( item, index, array ){ 
    return item > 3; 
  })); 
false
```

#### some

some()是对数组中每一项运行指定函数，如果该函数对**任一项**返回true，则返回true。不会改变原数组。

#### reduce

有返回，函数有四个参数，分别是：上一次的值，当前值，当前值的索引，数组。不会改变原数组。

`reduce() `方法接收一个函数作为累加器（accumulator），数组中的每个值（从左到右）开始缩减，最终为一个值。

```
[0, 1, 2, 3, 4].reduce(function(previousValue, currentValue, index, array){
   return previousValue + currentValue;
},0);
```

####  reduceRight

#### findIndex

有返回，不会改变原数组。对于数组中的每个元素，findIndex 方法都会调用一次回调函数（采用升序索引顺序），直到有元素返回 **true**。只要有一个元素返回 true，findIndex 立即返回该返回 true 的元素的**索引值**。如果数组中没有任何元素返回 true，**则 findIndex 返回 -1**。

```
1,2,3].findIndex(function(x) { x == 2; });// Returns an index value of 1.
[1,2,3].findIndex(x => x == 4);// Returns an index value of -1.
```

#### **keys，values，entries**

返回一个**遍历器对象**，可以用for...of循环进行遍历，唯一的区别是**keys()是对键名**的遍历、**values()是对键值**的遍历，**entries()是对键值对**的遍历

```
for(let index of ['a', 'b'].keys()) {
console.log(index);
}
// 0
// 1
for(let elem of ['a', 'b'].values()) {
console.log(elem);
}
// 'a'
// 'b'
for(let[index, elem] of ['a', 'b'].entries()) {
console.log(index, elem);
}
// 0 "a"
// 1 "b"
```

### promise

Promise 是异步编程的一种解决方案，所谓`Promise`，简单说就是一个容器，里面保存着某个未来才会结束的事件（通常是一个异步操作）的结果。从语法上说，Promise 是一个对象，从它可以获取异步操作的消息。

- Promise 操作只会处在 3 种状态的一种：未完成态(pending)、完成态(resolved) 和失败态(rejected);

- Promise 的状态只会出现从未完成态向完成态或失败态转化;

- Promise 的状态一旦转化，将不能被更改;

- Promise 新建后就会立即执行。

  Promise 新建后立即执行，所以首先输出的是`Promise`。然后，**`then`方法指定的回调函数，将在当前脚本所有同步任务执行完才会执行**，所以`resolved`最后输出。

```javascript
let promise = new Promise(function(resolve, reject) {
  console.log('Promise');
  resolve();
});

promise.then(function() {
  console.log('resolved.');
});

console.log('Hi!');

// Promise
// Hi!
// resolved
```

### js侦测数据变化的方式

1. Object.defineProperty

   `Object.defineProperty` 方法会直接在一个对象上定义一个新属性，或者修改一个对象的现有属性， 并返回这个对象，先来看一下它的语法：

   ```js
   Object.defineProperty(obj, prop, descriptor)
   ```

   `obj` 是要在其上定义属性的对象；`prop` 是要定义或修改的属性的名称；`descriptor` 是将被定义或修改的属性描述符。

   比较核心的是 `descriptor`，它有很多可选键值，具体的可以去参阅它的[MDN文档](https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Object/defineProperty)。这里我们最关心的是 `get` 和 `set`，`get` 是一个给属性提供的 getter 方法，当我们访问了该属性的时候会触发 getter 方法；`set` 是一个给属性提供的 setter 方法，当我们对该属性做修改的时候会触发 setter 方法。

   ```
   // 在对象中添加一个设置了存取描述符属性的示例
   var bValue = 38;
   Object.defineProperty(o, "b", {
     // 使用了方法名称缩写（ES2015 特性）
     // 下面两个缩写等价于：
     // get : function() { return bValue; },
     // set : function(newValue) { bValue = newValue; },
     get() { return bValue; },
     set(newValue) { bValue = newValue; },
     enumerable : true,
     configurable : true
   });
   o.b; // 38
   // 对象 o 拥有了属性 b，值为 38
   // 现在，除非重新定义 o.b，o.b 的值总是与 bValue 相同
   ```

   对象里目前存在的属性描述符有两种主要形式：*数据描述符*和*存取描述符*。*数据描述符*是一个具有值的属性，该值可以是可写的，也可以是不可写的。*存取描述符*是由 getter 函数和 setter 函数所描述的属性。一个描述符只能是这两者其中之一；不能同时是两者。数据描述符和存取描述符不能混合使用。混用报错。

   ```js
   // 数据描述符和存取描述符不能混合使用
   Object.defineProperty(o, "conflict", {
     value: 0x9f91102,
     get() { return 0xdeadbeef; } 
   });
   // 抛出错误 TypeError: value appears only in data descriptors, get appears only in accessor descriptors
   ```

   > Object.defineProperty是vue实现响应式监测数据变化的原理。
   >
   > 一旦对象拥有了 getter 和 setter，vue中我们可以简单地把这个对象称为响应式对象。
   >
   > ⚠️Object.defineProperty可以监测属性的变化，但是不能检测属性的增加和删除

2. Es6 proxy

   

### js对象的可枚举性和不可枚举性

**对象的每一个`属性`都有一个描述对象`description`，用来描述和控制该属性的行为，用`Object.getOwnPropertyDescriptor`方法来获取该描述对象（用`Object.defineProperty`方法来设置）。**

1.与可枚举性直接相关的描述对象`description`中的属性为`enumerable`当且仅当该属性的 `enumerable` 键值为 `true` 时，该属性才会出现在对象的枚举属性中。**默认为 `false`**。**通过赋值操作添加的普通属性是可枚举的。**

```
//这种情况enumerable为true
let obj = { start: '123' };
console.log(Object.getOwnPropertyDescriptor(obj, 'start'))

   // 输出内容：
     configurable: true
     enumerable: true
     value: "123"
     writable: true
```

2.可枚举属性，可用[`for...in`](https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Statements/for...in) 或 [`Object.keys`](https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Object/keys)[ ](https://developer.mozilla.org/en-US/docs/JavaScript/Reference/Global_Objects/Object/keys)方法枚举到

3.`JSON.stringify()`：只串行化对象自身的可枚举的属性。
4.`Object.assign()`： 忽略enumerable为false的属性，只拷贝对象自身的可枚举的属性。



## HTTP相关

### [图解http摘要](https://juejin.im/post/5c938812e51d4539fc2d61a5#heading-13 ) -作为参考
### 前端缓存 
#### 参考链接 [前端缓存详解](https://www.jianshu.com/p/256d0873c398)
![image-20200330183803654](/Users/xihaa/Library/Application Support/typora-user-images/image-20200330183803654.png)
#### HTTP缓存
##### 补充：协商缓存

- 涉及到有缓存状态更新的情况最后一步都是**将请求结果和缓存标识存入浏览器缓存中**
- 控制协商缓存的字段：Last-Modified / If-Modified-Since和Etag / If-None-Match，其中Etag / If-None-Match的优先级比Last-Modified / If-Modified-Since高。

> Etag / If-None-Match 是一对
>
> Etag是**服务器响应请求**时，返回**当前资源文件的一个唯一标识**(由服务器生成)
>
> If-None-Match是**客户端再次发起该请求**时，携带上次请求返回的唯一标识Etag值，通过此字段值告诉服务器该资源上次请求返回的唯一标识值。
>
> 服务器收到该请求后，发现该请求头中含有If-None-Match，则会根据If-None-Match的字段值与该资源在服务器的Etag值做对比，一致则返回304，代表资源无更新，继续使用缓存文件；不一致则重新返回资源文件，状态码为200。

> Last-Modified / If-Modified-Since 是一对
>
> Last-Modified是**服务器响应请求**时，返回该资源文件在服务器**最后被修改的时间**
>  If-Modified-Since则是**客户端再次发起该请求**时，携带上次请求返回的Last-Modified值，通过此字段值告诉服务器该资源**上次请求返回的最后被修改时间**。
>  服务器收到该请求，发现请求头含有If-Modified-Since字段，则会根据If-Modified-Since的字段值与该资源在服务器的最后被修改时间做对比，若服务器的资源最后被修改时间大于If-Modified-Since的字段值，则重新返回资源，状态码为200；否则则返回304，代表资源无更新，可继续使用缓存文件。

##### 总结：强制缓存优先于协商缓存进行，若强制缓存(Expires和Cache-Control)生效则直接使用缓存，若不生效则进行协商缓存(Last-Modified / If-Modified-Since和Etag / If-None-Match)，协商缓存由服务器决定是否使用缓存，若协商缓存失效，那么代表该请求的缓存失效，重新获取请求结果，再存入浏览器缓存中；生效则返回304，继续使用缓存，主要过程如下：<img src="/Users/xihaa/Library/Application Support/typora-user-images/image-20200411022910360.png" alt="image-20200411022910360" style="zoom:50%;" />

#### CDN-内容分发网络
尽可能避开互联网上有可能影响数据传输速度和稳定性的瓶颈和环节，使内容传输的更快、更稳定。

CDN就是一个分布式的缓存服务器，存着非常多文件，并且分布在世界各地，每个人都能就近访问。我们讲个通俗的例子，可乐公司上市了一款新的可乐，本来你要到美国去买，现在可乐公司把可乐运到了你楼下的小卖部，你只要下楼就能买到，更加方便快捷！

<img src="/Users/xihaa/Library/Application Support/typora-user-images/image-20200412153933287.png" alt="image-20200412153933287" style="zoom: 33%;" />


#### 缓存用法
vue项目：index.html文件采用协商缓存，理由就是要用户每次请求index.html不拿浏览器缓存，直接请求服务器，这样就保证资源更新了，用户能马上访问到新资源，如果服务端返回304，这时候再拿浏览器的缓存的index.html，切记不要设置强缓存！！！

其他资源采用强缓存 + 协商缓存。

### 一台服务器如何配置多个域名-单台虚拟主机？

一是在发送请求时必须请求头部字段中增加Host字段，表明请求的主机名

二是在一台服务器上使用不同的IP地址来管理多个服务。


### TCP/IP基础

<img src="/Users/xihaa/Library/Application Support/typora-user-images/image-20200331003524904.png" alt="image-20200331003524904" style="zoom: 33%;" />

可以看出http是基于TCP/IP协议的

<img src="/Users/xihaa/Library/Application Support/typora-user-images/image-20200331011907312.png" alt="image-20200331011907312" style="zoom:50%;" />

**三次握手讲解：**

1. 客户端发送位码为syn＝1,随机产生seq number=1234567的数据包到服务器，服务器由SYN=1知道客户端要求建立联机（客户端：我要连接你）
2. 服务器收到请求后要确认联机信息，向A发送ack number=(客户端的seq+1),syn=1,ack=1,随机产生seq=7654321的包（服务器：好的，你来连吧）
3. 客户端收到后检查ack number是否正确，即第一次发送的seq number+1,以及位码ack是否为1，若正确，客户端会再发送ack number=(服务器的seq+1),ack=1，服务器收到后确认seq值与ack=1则连接建立成功。（客户端：好的，我来了）

面试官：为什么http建立连接需要三次握手，不是两次或四次
答：三次是最少的安全次数，两次不安全，四次浪费资源

### HTTP请求报文
HTTP请求报文主要包括请求行、请求头部以及请求的数据（实体）三部分

<img src="/Users/xihaa/Library/Application Support/typora-user-images/image-20200409231621143.png" alt="image-20200409231621143" style="zoom:33%;" />

#### 请求行/起始行
**包含了一个方法和一个请求URL**，这个方法描述了服务器应该执行的操作，请求URL描述了要对哪个资源执行这个方法。请求行中还**包含HTTP 的版本**，用来告知服务器，客户端使用的是哪种HTTP。所有这些字段都由空格符分隔。
例如：POST /infoNewsAction_uploadxheditorfile.action?immediate=1 HTTP/1.1

#### HTTP首部

参考链接  https://juejin.im/post/5a687dd7518825732f7ee8e5#heading-5

##### 通用首部

1. **Cache-Control指令:**  能够控制缓存的工作行为。

   <img src="/Users/xihaa/Library/Application Support/typora-user-images/image-20200401222502965.png" alt="image-20200401222502965" style="zoom:50%;" />

2. **Connection** ： **控制不再转发给代理服务器的首部字段**；**持久连接:** 即`Connection: keep-alive`

3. ***其他

##### 请求首部字段

1. **Host**

   Host字段会告知服务器请求的资源所处的互联网主机名和端口号。请求被发送到服务器时，会使用DNS服务将域名解析成IP地址。如果此时相同的IP地址下部署了多个域名(虚拟主机)，那么服务器就无法理解究竟是哪个域名对应的请求。因此就需要使用Host字段来明确指出请求的主机名。
   
2. Accept

   通知服务器，用户代理能够处理的媒体类型及媒体类型的相对优先级。

3. If-Match
    形如 If-xxx 这种，都可称为条件请求。服务器接收到后，只有判断指定条件为真时，才会执行请求。If-Match属附带条件之一，它会告知服务器匹配资源所用的实体标记（ETag）值。这时的服务器无法使用弱 ETag 值。服务器会比对 If-Match 的字段值和资源的 ETag 值，仅当两者一致时，才会执行请求。
    可以用星号 *，服务器会忽略 ETag 的值，只要资源存在就处理请求。

4. If-None-Match
   和 If-Match 作用相反，用于指定 If-None-Match 的实体标记 ETag 值与请求资源的 ETag 不一致时，它就告知服务器处理该请求。

5. If-Modified-Since
   如果在 If-Modified-Since 字段指定的日期时间后资源发生了更新，服务器会接受请求。
   指定 If-Modified-Since 字段值的日期时间之后，请求的资源在给定的日期时间之后对内容进行过修改的情况下才会将资源返回，状态码为 200，如果请求的资源没有更新，则返回状态码 304 Not Modified 的响应。

6. If-Unmodified-Since
   If-Unmodified-Since 和 If-Modified-Since 的作用相反。它的作用的是告知服务器，指定的请求资源只有在指定日期时间之后未发生更新，才处理请求。如果在指定日期时间后发生了更新，则以状态码 412 Precondition Failed 作为响应返回。

7. If-Range
   If-Range 字段如果跟 ETag 值或更新的日期时间一致，那么就作为范围请求处理。反之，则返回全体资源。

   

##### 响应首部字段

1. Location

   令客户端重定向至指定URI，跟状态码有关。3xx状态码，返回重定向的Location
   
2. Etag 

   服务器响应请求时，返回当前资源文件的一个唯一标识（由服务器生成）

##### 实体首部字段

1.  **Allow**

   `Allow: GET, POST`。Allow字段用于通知客户端能够支持的HTTP方法。当服务器接收到不支持的HTTP方法时，会以状态码405 Method Not Allowed作为响应返回。

2. **Content-Type**

   告诉客户端实际返回的内容的内容类型

   ![image-20200401172325617](/Users/xihaa/Library/Application Support/typora-user-images/image-20200401172325617.png)
   
3. Expires

   `Expires` 会将资源失效的日期告知客户端。缓存服务器在收到有 `Expires` 的响应后，会以缓存来应答请求，在 `Expires` 字段值指定的时间之前，响应的副本会一直被保存。当超过指定的时间后，缓存服务器在请求发送过来时，会转向源服务器请求资源。

   源服务器不希望缓存服务器对资源缓存时，最好在 `Expires` 字段内写入与 `Date` 相同的时间值。

   但是，当首部字段 `Cache-Control` 有指定 `max-age` 时，比起 `Expires`，会优先处理 `max-age` 指令。 到了HTTP/1.1，Expire已经被Cache-Control替代，原因在于Expires控制缓存的原理是使用客户端的时间与服务端返回的时间做对比，那么如果客户端与服务端的时间因为某些原因（例如时区不同；客户端和服务端有一方的时间不准确）发生误差，那么强制缓存则会直接失效，这样的话强制缓存的存在则毫无意义。

4. Last-Modified

  包含源头服务器认定的资源做出修改的日期及时间。

#### 为 Cookie 服务的首部字段

| **首部字段名** | **说明**                       | **首部类型** |
| -------------- | ------------------------------ | ------------ |
| Set-Cookie     | 开始状态管理所使用的Cookie信息 | 响应首部字段 |
| Cookie         | 服务器接收到的Cookie信息       | 请求首部字段 |



#### 实体/请求的数据

包括了要发送给Web 服务器的数据

MIME 类型是一种文本标记，表示一种主要的对象类型和一个特定的子类型，中间由一条斜杠来分隔。

• HTML 格式的文本文档由 text/html 类型来标记。

•普通的 ASCII 文本文档由 text/plain 类型来标记。

• JPEG 格式的图片为 image/jpeg 类型。

• GIF 格式的图片为 image/gif 类型。



### Web存储

#### cookie

##### cookie诞生原因

http是无状态无连接的，如果服务器要用到上次连接的信息，就必须用什么东西保存。Cookie诞生的最初目的是为了存储web中的状态信息，以方便服务器端使用
##### 


### URI和URL的区别
URI：Uniform Resource Identifier，统一资源标识符
URL：Uniform Resource Location统一资源定位符

1. URI，是统一资源标识符，用来唯一的标识一个资源。而URL是统一资源定位器，它是一种具体的URI，即URL可以用来标识一个资源，而且还指明了如何locate这个资源。而URN，统一资源命名，是通过名字来标识资源，比如[mailto:java-net@java.sun.com](https://link.jianshu.com?t=mailto:java-net@java.sun.com)。也就是说，URI是以一种抽象的，高层次概念定义统一资源标识，而URL和URN则是具体的资源标识的方式。URL和URN都是一种URI；
2. URL是URI的一种（通过那个图就看的出来吧）。但也不是所有的URI都是URL哦，就好像蝴蝶都会飞，但会飞的可不都是蝴蝶啊！
3. URL是URI最常见的一种形式
### HTTP状态码
[状态码参考](https://segmentfault.com/a/1190000018264501)

#### 304Not Modified-协商缓存生效
这种响应一般是GET请求中带有附加条件，例如请求头中含有if-Match,if-Modified-Since等（if-Match表示只请求带有特殊标记的资源，if-Modified-Since表示请求指定时间后未变更的资源，因为本文主要讲解状态码，所以不在此引入太多http头部的相关内容，这里是为了简单解释下附加条件请求的含义）。

这种情况下，服务端不会返回响应主体，含义就是：”从你上次访问以来这个资源都没变过哟，直接使用你本地的缓存就行啦“。

<img src="/Users/xihaa/Library/Application Support/typora-user-images/image-20200411014657444.png" alt="image-20200411014657444" style="zoom:50%;" />

### get和post的区别	

![image-20200410201338840](/Users/xihaa/Library/Application Support/typora-user-images/image-20200410201338840.png)

GET在浏览器回退时是无害的，而POST会再次提交请求。

GET产生的URL地址可以被添加到书签，而POST不可以。

GET请求会被浏览器主动cache，而POST不会，除非手动设置。

GET请求只能进行url编码，而POST支持多种编码方式。

GET请求参数会被完整保留在浏览器历史记录里，而POST中的参数不会被保留。

GET请求在URL中传送的参数是有长度限制的，而POST没有。

对参数的数据类型，GET只接受ASCII字符，而POST没有限制。

GET比POST更不安全，因为参数直接暴露在URL上，所以不能用来传递敏感信息。

GET参数通过URL传递，POST放在Request body中。

GET 请求可被缓存；POST 请求不会被缓存。

GET 请求可被收藏为书签；POST 不能被收藏为书签。
>对于 GET 方式的请求**，浏览器会把 HTTP header 和 data 一并发送出去，服务器响应 200（返回数据）**。
而对于 POST，**浏览器先发送 header ，服务器响应 100 continue ，浏览器再发送 data ，服务器响应 200 ok（返回数据）**。
本质上来说：get和post本质上都是基于TCP/IP的HTTP协议的请求方式，也就是说这两者本质上TCP连接。此外，要注意：**GET产生一个TCP数据包；POST产生两个TCP数据包。**
**也就是说，GET 只需要汽车跑一趟就把货送到了，而 POST得跑两趟，第一趟，先去和服务器打个招呼“嗨，我等下要送一批货来，你们打开门迎接我”，然后再回头把货送过去。**
ps：不过要注意，POST 具体发几次，也和浏览器的实现有关系。例如：Firefox 只发一次。 ps2：据研究，在网络环境好的情况下，发一次包的时间和发两次包的时间差别基本可以无视。而在网络环境差的情况下，两次包的 TCP 在验证数据包完整性上，有非常大的优点。

### 在浏览器输入URL经历了什么过程

#### 参考链接 [（超详细版）  ](https://www.cnblogs.com/jin-zhe/p/11586327.html)&  [过程图](https://juejin.im/post/5e57b872e51d4527110a8c72)

见思维导图

#### 补充-浏览器渲染界面的过程

#### <img src="/Users/xihaa/Library/Application Support/typora-user-images/image-20200411040221532.png" alt="image-20200411040221532" style="zoom:33%;" />

　**回流(reflow)**

　　　　当浏览器发现某个部分发现变化影响了布局时，需要倒回去重新渲染，会从`html`标签开始递归往下，重新计算位置和大小。

　　　　reflow基本是无法避免的，因为当你滑动一下鼠标、resize 窗口，页面就会产生变化。

　　**重绘(repaint)**

　　　　改变了某个元素的背景色、文字颜色等等不会影响周围元素的位置变化时，就会发生重绘。

　　　　每次重绘后，浏览器还需要合并渲染层并输出到屏幕上。

　　　　回流的成本要比重绘高很多，所以我们应该尽量避免产生回流。

　　比如：display:none` 会触发回流，`而 `visibility:hidden` 只会触发重绘。




### 轮询、长轮询、长连接SSE、websocket

https://juejin.im/post/5cacb459f265da03a00fb2fe

1. 轮询

   当前Web应用中较常见的一种持续通信方式，通常采取 setInterval 或者 setTimeout 实现。例如如果我们想要定时获取并刷新页面上的数据

   程序在每次请求时都会新建一个HTTP请求，然而并不是每次都能返回所需的新数据。当同时发起的请求达到一定数目时，会对服务器造成较大负担。

2. 长轮询

   当服务器收到客户端发来的请求后,服务器端不会直接进行响应，而是先将这个请求挂起，然后判断服务器端数据是否有更新。如果有更新，则进行响应，如果一直没有数据，则到达一定的时间限制(服务器端设置)才返回

   **轮询与长轮询都是基于HTTP的**，两者本身存在着缺陷:轮询需要更快的处理速度；长轮询则更要求处理并发的能力;两者都是“**被动型服务器**”的体现:服务器不会主动推送信息，而是在客户端发送ajax请求后进行返回的响应。而理想的模型是"在服务器端数据有了变化后，可以主动推送给客户端",这种"主动型"服务器是解决这类问题的很好的方案。Web Sockets就是这样的方案。

3. 长连接

   　SSE是HTML5新增的功能，全称为Server-Sent Events。它可以允许服务推送数据到客户端。SSE在本质上就与之前的长轮询、短轮询不同，虽然都是基于http协议的，但是轮询需要客户端先发送请求。而SSE最大的特点就是不需要客户端发送请求，可以实现只要服务器端数据有更新，就可以马上发送到客户端。

      　　SSE的优势很明显，它不需要建立或保持大量的客户端发往服务器端的请求，节约了很多资源，提升应用性能。并且后面会介绍道

4. websocket

   该协议可以实现服务器与客户端之间**全双工通信**。简单来说，首先需要在客户端和服务器端建立起一个连接，这部分需要http。连接一旦建立，客户端和服务器端就处于平等的地位，可以相互发送数据，不存在请求和响应的区别。

   WebSocket的优点是实现了**双向通信**，缺点是服务器端的逻辑非常复杂。
   
   <img src="/Users/xihaa/Library/Application Support/typora-user-images/image-20200410152952454.png" alt="image-20200410152952454" style="zoom: 33%;" />

从**兼容性**角度考虑，短轮询>长轮询>长连接SSE>WebSocket；

从**性能方面**考虑，WebSocket>长连接SSE>长轮询>短轮询。

### 确保 Web 安全的 HTTPS
####  HTTP 的缺点
1. 通信使用明文（不加密），内容可能会被窃听

2. 不验证通信方的身份，因此有可能遭遇伪装

3. 无法证明报文的完整性，所以有可能已遭篡改

#### HTTP+ 加密 + 认证 + 完整性保护 = HTTPS

**把添加了加密及认证机制的 HTTP 称为 HTTPS（HTTP Secure）**

HTTPS 并非是应用层的一种新协议，只是 HTTP 通信接口部分用 SSL（Secure Socket Layer）和 TLS（Transport Layer Security）协议代替而已。SSL 是独立于 HTTP 的协议，所以其他运行在应用层的 SMTP 和 Telnet 等协议均可配合 SSL 协议使用。

<img src="/Users/xihaa/Library/Application Support/typora-user-images/image-20200410122802170.png" alt="image-20200410122802170" style="zoom: 33%;" />

HTTPS 采用共享密钥加密和公开密钥加密两者并用的混合加密机制。

### HTTP的各种版本

- HTTP/0.9

​    HTTP协议的最初版本，功能简陋，仅支持请求方式GET，并且仅能请求访问HTML格式的资源。

- HTTP/1.0  

​    在0.9版本上做了进步，增加了请求方式POST和HEAD；不再局限于0.9版本的HTML格式，根据Content-Type可以支持多种数据格式，即MIME多用途互联网邮件扩展，例如text/html、image/jpeg等；同时也开始支持cache，就是当客户端在规定时间内访问统一网站，直接访问cache即可。

​    但是1.0版本的工作方式是每次TCP连接只能发送一个请求，当服务器响应后就会关闭这次连接，下一个请求需要再次建立TCP连接，就是不支持keepalive。

- HTTP/1.1   

​    解决了1.0版本的keepalive问题，1.1版本加入了持久连接，一个TCP连接可以允许多个HTTP请求； 加入了管道机制，一个TCP连接同时允许多个请求同时发送，增加了并发性；新增了请求方式PUT、PATCH、DELETE等。

​    但是还存在一些问题，服务端是按队列顺序处理请求的，假如一个请求处理时间很长，则会导致后边的请求无法处理，这样就造成了队头阻塞的问题；同时HTTP是无状态的连接，因此每次请求都需要添加重复的字段，降低了带宽的利用率。

- HTTP/2.0

​    为了解决1.1版本利用率不高的问题，提出了HTTP/2.0版本。增加双工模式，即不仅客户端能够同时发送多个请求，服务端也能同时处理多个请求，解决了队头堵塞的问题；HTTP请求和响应中，状态行和请求/响应头都是些信息字段，并没有真正的数据，因此在2.0版本中将所有的信息字段建立一张表，为表中的每个字段建立索引，客户端和服务端共同使用这个表，他们之间就以索引号来表示信息字段，这样就避免了1.0旧版本的重复繁琐的字段，并以压缩的方式传输，提高利用率。

HTTP/2不再是一个基于文本的协议，通过新增的二进制分帧层变成了一个**二进制协议**，这意味着：

HTTP/2使用二进制帧进行数据交换。HTTP/2规范中一共定义了10种帧，其中最基础的两种分别对应于HTTP/1.1的DATA和HEADERS帧

HTTP/2可以对压缩头信息进行压缩了。反正是二进制帧

​    另外也增加服务器推送的功能，即不经请求服务端主动向客户端发送数据。

当前主流的协议版本还是HTTP/1.1版本。
### 跨域

跨域，是指浏览器不能执行其他网站的脚本。它是由浏览器的同源策略造成的，是浏览器对JavaScript实施的安全限制。所谓的同源是指，域名、协议、端口均为相同。

同源策略限制了一下行为：

- Cookie、LocalStorage 和 IndexDB 无法读取
- DOM 和 JS 对象无法获取
- Ajax请求发送不出去

#### 跨域的解决办法
##### jsonp跨域
jsonp跨域其实也是JavaScript设计模式中的一种代理模式。因为script标签不受同源策略的限制，所以可能动态生成script标签的方式来实现跨域。

```
//原生的实现方式
let script = document.createElement('script');

script.src = 'http://www.nealyang.cn/login?username=Nealyang&callback=callback';

document.body.appendChild(script);

function callback(res) {
  console.log(res);
}
复制代码

```

当然，jquery也支持jsonp的实现方式

```
$.ajax({
    url:'http://www.nealyang.cn/login',
    type:'GET',
    dataType:'jsonp',//请求方式为jsonp
    jsonpCallback:'callback',
    data:{
        "username":"Nealyang"
    }
})
```

虽然这种方式非常好用，但是一个最大的缺陷是，**只能够实现get请求**。

#### document.domain + iframe 跨域

#### 跨域资源共享 CORS

CORS是一个W3C标准，全称是"跨域资源共享"（Cross-origin resource sharing）。 它允许浏览器向跨源服务器，发出XMLHttpRequest请求，从而克服了**AJAX只能同源使用**的限制。

CORS需要浏览器和服务器同时支持。目前，所有浏览器都支持该功能，IE浏览器不能低于IE10。IE8+：IE8/9需要使用XDomainRequest对象来支持CORS。

整个CORS通信过程，都是浏览器自动完成，不需要用户参与。对于开发者来说，CORS通信与同源的AJAX通信没有差别，代码完全一样。浏览器一旦发现AJAX请求跨源，就会自动添加一些附加的头信息，有时还会多出一次附加的请求，但用户不会有感觉。 因此，实现CORS通信的关键是服务器。**只要服务器实现了CORS接口，就可以跨源通信。**

### XSS风险

- XSS形成原因

  系统将用户输入的脚本代码执行了，违背了原本接收数据的本意。造成一些意想不到的后果。原因是系统没有对用户输入数据进行编码，转义，过滤限制等处理。

- XSS分类

  下浏览器与服务器架构层次：***User - IE(Chrome) - Java/PHP/Python - DB ***

  1. 反射型：用户使用浏览器，然后浏览器发送请求到服务器后台的Java或者PHP，或者Python，然后服务器逻辑程序返回响应结果，传送到客户端浏览器显示。
  2. 存储型：用户使用浏览器发送请求到服务器，应用逻辑向数据库存取数据，（**XSS代码存储在DB中**），再经过应用程序发送响应传送到浏览器显示。
  3. DOM-Based型：只涉及用户浏览器，变化只发生在客户端的JS与HTML之间。不涉及服务器交互。

- XSS后果

  - 将 cookie 或 token 等类似令牌数据上报给黑客，黑客就能以受害用户的权限进行操作
  - 运行恶意脚本的用户浏览器可能被操控继续攻击其他目标
  - 有黑客利用 XSS 嗅探内网服务，然后发起下一步的攻击

- 可能出现XSS的情况

  1. 未将cookie标记为**httponly**，用js来获取cookie（document.cookie）

  2. vue的v-html指令

     > 解决方法：直接大括号的方式
     >
     > ```
     > <div>{{ title }}</div>
     > ```
     >
     > 试一试，输入`alert('get')`
     > 结果：直接显示`alert('get')`
     >
     > 并且使用次指令，会使里面的子组件被覆盖不显示

- 预防XSS

  1. 转义

      一般来说，对用户输入的数据，尤其是这6个字符：**>'&/<"**，具体编码目标格式应结合具体情况而定，对相应数据进行HtmlEncode，JavascriptEncode，URLEncode，甚至对CSS里的数据运行相应的OWASP ESAPI中的encodeForCSS()函数。具体用哪一种编码方式，需要看系统将数据输出显示在哪个位置，是JS里，是HTML里，还是CSS里。

  2. 黑白名单过滤

     设置内容白名单，只允许信得过、频繁出现且正当的内容。比如<a><p>等。因为<script>容易出现XSS，设置黑名单就是采用直接去除的方式。但是这种方式会漏掉一些内容，造成错误。

  3. Content Security Policy

     内容安全性政策 (CSP) 是一个可显著降低现代浏览器中 XSS 攻击的风险和影响的防护功能。 它允许网页的作者控制可以从哪里加载和执行JavaScript（和其他资源）。XSS攻击依赖于攻击者能够在用户的网页上运行恶意脚本 - 通过 `` 在 `` 页面标记内的某处插入内联标记，或者通过诱骗浏览器从恶意第三方域加载JavaScript。 通过在响应头中设置内容安全策略，您可以告诉浏览器永远不会执行内嵌 JavaScript，并锁定哪些域名可以为页面托管 JavaScript。


## CSS相关
### display: none与visibility: hidden的区别

1. display: none元素和后代元素消失且不占空间，visibility: hidden只是不可见仍占据空间
2. 在css3的transition中支持visibility属性，但是不支持display，因为transition可以延迟执行，因此配合visibility使用纯css实现hover延时显示效果可以提高用户体验
3. visibility不会影响计数器的计算，虽然隐藏掉了，但是计数器依然继续运行着。
4. visibility具有继承性，其子元素也会继承此属性，若设置visibility:visible，则子元素会显示；display: none的元素其子元素如果设置显示，经测试还是显示不出来

### position

[参考链接：css布局实践](https://www.yuque.com/fe9/basic/ecdg1z)

在布局中很重要的因素就是定位，position 属性就是用来定义元素的定位机制。position 的常用属性值有：

- relative：相对定位，相对于元素的正常位置进行定位；

- absolute：绝对定位，相对于**除 static 定位以外的元素**进行定位；**最近的除 static 定位以外的元素进行定位**，在使用时要注意设置父元素（或祖先元素）的 position 属性，若父元素（或祖先元素）都没有设置定位属性，absolute 会找到**最上层即浏览器窗口**，相对于它进行定位了。

- fixed：固定定位，相对于**浏览器窗口**进行定位，网站中的固定 header 和 footer 就是用固定定位来实现的；

- static：默认值，没有定位属性，元素**正常出现在文档流**中；

- inherit：继承父元素的 position 属性值。

上文出现了文档流（normal flow）的概念，按理来说应该翻译成普通流，文档流是大多数人的叫法。“流”可以想象成流动的水，当我们打开屏幕，浏览网页，滚动鼠标，网页的内容就像是水流一样滑过。文档流便是指从上到下，从左往右的文档布局。当我们给元素的 positon 属性设置 absolute、fixed 时便会脱离文档流，不再遵循从上到下，从左到右的规律了。

1. relative 示例

```
<div class="common box_1">box 1</div>
<div class="common box_2">box 2</div>
<div class="common box_3">box 3</div>
.common {
    width: 100px;
    height: 100px;
    text-align: center;
}
.box_1 {
    position: relative;
    background-color: #FFB5BF;
}
.box_2 {
    position: relative;
    background-color: #94E8FF;
    left: 10px;
    top: 10px;
}
.box_3 {
    background-color: #8990D5;
}
```

![img](https://cdn.nlark.com/yuque/0/2018/png/199663/1542099035392-c9145616-9e1d-442e-a0af-4cdeaa82ad1a.png)

（position 为 relative 示例）



从上图中我们不难发现，设置 position 为 relative，但是不添加额外属性（left，right，top，bottom 等），它表现的如同 static 一样，如 .box_1。属性 left，right，top，bottom 会使元素偏离正常位置，如 .box_2。元素的偏移会覆盖相邻元素，如 .box_3。



1. absolute 示例



```
<div class="relative">
    relative
    <div class="absolute">absolute</div>
</div>
.relative {
    width: 200px;
    height: 200px;
    border: 2px solid #FFB5BF;
    position: relative;
}
.absolute {
    width: 100px;
    height: 100px;
    border: 2px solid #94E8FF;
    position: absolute;
    bottom: 10px;
    right: 10px;
}
```



![img](https://cdn.nlark.com/yuque/0/2018/png/199663/1541153446814-49bcb2ad-4e0b-419e-827d-d78468436328.png)

（position 为 absolute 示例）



absolute 会相对于最近的除 static 定位以外的元素进行定位，在使用时要注意设置父元素（或祖先元素）的 position 属性，若父元素（或祖先元素）都没有设置定位属性，absolute 会找到最上层即浏览器窗口，相对于它进行定位了。



1. fixed 示例



```
<div class="fixed"></div>
<span>The p tag defines a paragraph. Browsers automatically add some space (margin) before and after each p element...</span>
...
<span>The p tag defines a paragraph. Browsers automatically add some space (margin) before and after each p element...</span>
.fixed {
    width: 100px;
    height: 100px;
    background-color: #FFB5BF;
    position: fixed;
    left: 20px;
    top: 20px;
}
```



![img](https://cdn.nlark.com/yuque/0/2018/gif/199663/1541254100244-49caa7b5-4306-48d4-9d0c-7f52d903ef26.gif)

（position 为 fixed 示例）



fixed 是相对于浏览器窗口的定位，一旦位置确定， 元素位置也不会改变，不像 absolute，它的位置与父元素息息相关，父元素移动它也会跟着动。从上图我们可以看出，fixed 元素是脱离文档流的，之后的元素会“无视”它，不会给它腾出空间。



#### float



float 属性定义元素在哪个方向浮动，常用属性值有 `left`、`right`，即向左浮动和向右浮动。设置了 float 的元素，会脱离文档流，然后向左或向右移动，直到碰到父容器的边界或者碰到另一个浮动元素。块级元素会忽略 float 元素，文本和行内元素却会环绕它，所以 float 最开始是用来实现文字环绕效果的。



```
<div class="container">
    <div class="box_1">box 1</div>
    <div class="box_2">The young applicant is described as confident and courageous. His résumé, at 15 pages, is glittering, ...</div>
</div>
.container {
    width: 100%;
    height: 150px;
    background-color: #94E8FF;
}
.box_1 {
    width: 100px;
    height: 100px;
    text-align: center;
    background-color: #FFB5BF;
    float: left;
}
```



![img](https://cdn.nlark.com/yuque/0/2018/png/199663/1542100692264-8285eebc-9b9e-4432-9b75-ce3f69d6f650.png)

（文字环绕效果）



我们知道，当不给父元素设置宽高时，父元素的宽高会被子元素的内容撑开。但是当子元素设置浮动属性后，子元素会溢出到父元素外，父元素的宽高也不会被撑开了，称之为“高度塌陷”，我们通过代码来体验一下这个差异。



```
<div class="container">
    <div class="box_1 float">box 1</div>
    <div class="box_2 float">box 2</div>
</div>
.container {
    border: 3px solid #8990D5;
}
.box_1 {
    height: 100px;
    width: 100px;
    text-align: center;
    background-color: #FFB5BF;
}
.box_2 {
    height: 100px;
    width: 100px;
    text-align: center;
    background-color: #94E8FF;
}
.float {
    float: left;
}
```



![img](https://cdn.nlark.com/yuque/0/2018/png/199663/1542101158483-70cd8404-9711-4f92-ba85-eb8a6a4d8fc1.png)

（浮动的子元素不能撑开父元素）



如何解决这个问题呢？解决这个问题便是要**清除浮动**，在下面我们给出了几种常规解决方案。





1. 通过添加额外的标签，利用 clear 属性来清除浮动



clear 属性用来定义哪一侧不允许其他元素浮动，常见的值有 `left` 、`right`、`both`， 分别表示左侧不允许浮动元素、右侧不允许浮动元素、左右两侧均不允许浮动元素。



```
<div class="container">
    <div class="box_1 float">box 1</div>
    <div class="box_2 float">box 2</div>
    <div class="clear"></div>
</div>
.clear {
    clear: both;
}
```



![img](https://cdn.nlark.com/yuque/0/2018/png/199663/1542101355460-8f31e922-516d-4860-9c86-d389d18162aa.png)

（使用 clear: both 后把父元素撑开了）



1. 使用 br 标签



br 自带 clear 属性，clear 属性有 left、right 和 all 三个属性值可选。



```
<div class="container">
    <div class="box_1 float">box 1</div>
    <div class="box_2 float">box 2</div>
    <br clear="all"></br>
</div>
```



该方法同上一个方法添加空标签一样，也达到了清除浮动的目的，同上一个方法相比，语义化明显些了，但是也存在结构样式行为分离的问题，不推荐使用。





1. 给父元素设置 overflow



```
<div class="container overflow">
    <div class="box_1 float">box 1</div>
    <div class="box_2 float">box 2</div>
</div>
.overflow {
    overflow: hidden;
    zoom: 1;   /* 兼容 IE6、IE7*/
}
```



添加 overflow 不仅减少了代码量，还不存在语义化的问题，但是也可能因为内容增加导致超出尺寸的内容被隐藏。前面两个方法带有 clear 关键字，很好理解，但是仅仅设置 `overflow: hidden;` 为什么就能清除浮动呢？

这里要引入一个概念：[BFC](https://developer.mozilla.org/zh-CN/docs/Web/Guide/CSS/Block_formatting_context)（Block Formatting Context），块级格式化上下文。BFC 的一个特性便是可以包含浮动元素，设置 overflow 为 hidden 满足了创建一个 BFC 的条件，其实就是创建 BFC，利用 BFC 固有特性清除浮动，这里不做过多讲解，有兴趣的伙伴可以查阅相关资料。

1. 使用 after 伪元素

```
<div class="container">
    <div class="box_1 float">box 1</div>
    <div class="box_2 float">box 2</div>
</div>
.container::after {
    content: '';
    clear: both;
    display: block;
    height: 0;
    visibility: hidden;
}
.container {
    border: 3px solid #ccc;
    zoom: 1;   /* 兼容 IE6、IE7 */
}
```

该方法本质也是在末尾添加一个看不见的块元素来清除浮动。这个方法也不存在语义化的问题，是目前的主流清除浮动的方法。

### css盒子模型

在网页布局中，我们可以将 HTML 标签看成一个个矩形盒子，盒模型就是用来描述这些矩形盒子所占的空间大小。

#### 相关属性

- [width 和 height 分别指定了一个元素的宽高](https://www.yuque.com/fe9/basic/pdrpr8#4eb6851e)
- [border 指元素的边框](https://www.yuque.com/fe9/basic/pdrpr8#cfbd5a78)
- [padding 指内边距，是元素内容和边框之间的部分](https://www.yuque.com/fe9/basic/pdrpr8#d0cc727d)
- [margin 指外边距，用来定义元素周围的空间](https://www.yuque.com/fe9/basic/pdrpr8#0008aeb5)

#### 盒模型的分类

由于浏览器的差异性，盒模型分为标准盒模型和IE盒模型，它们的呈现方式和对盒子大小的计算略有不同，我们先通过代码示例来体验一下差异。

#####  box-sizing属性

**`box-sizing`** 属性定义了 [user agent](https://developer.mozilla.org/zh-CN/docs/Glossary/User_agent) 应该如何计算一个元素的总宽度和总高度。

- content-box—标准盒模型

  是默认值。如果你设置一个元素的宽为100px，那么这个元素的内容区会有100px 宽，并且任何边框和内边距的宽度都会被增加到最后绘制出来的元素宽度中。即width/height仅代表**内容区的宽高度**，**不包括内边距和边框**。

- border-box— IE 盒模型。

  width/height的值包括**内边距和边框**。大多数情况下，这使得我们更容易地设定一个元素的宽高。（有种拿固定的木盒子罩住元素的感觉）

  **Note:** *对于新的web站点，你可能希望首先将box-sizing设置为border-box，如下所示：*

  *\* { box-sizing: border-box; }*

  *这使得处理元素大小的工作变得容易得多，并且通常消除了在布局内容时可能遇到的许多陷阱。然而，在某些情况下，你应谨慎使用这个属性。例如： 你正在编写一个将由其他人使用的共享组件库，如果他们网站的其余部分没有设置此值，他们可能会发现很难使用你的组件库。*

- inherit

  规定应从父元素继承 box-sizing 属性的值。

#### 浏览器兼容性及其他

- 只要设置了合适的 DTD，大多数浏览器会按照标准盒模型来显示，但是 IE5.X 和 6 在怪异模式下会根据 IE 盒子模型进行显示。
- 标准盒模型下元素的 box-sizing 属性（IE8+）默认值为 content-box，将它设置成 border-box 可转换为 IE 盒模型。在实际应用场景中，若想控制元素总宽高保持固定，这个设置很有用。
- 元素的宽（width）、高（height）、边框（border）、内边距（padding）、外边距（margin）都是盒子模型的重要组成部分，但是盒子模型的大小只与元素的宽高、边框、内间距有关，外边距只影响盒子所占外围空间的大小

### flex布局

[参考链接：flex布局](https://www.yuque.com/fe9/basic/tlk8ck#b2c744d3)

display 是 CSS 布局中很重要的一个属性，它定义了元素生成的显示框类型，常见的几个属性值有：`block`、`inline`、`inline-block`、`inherit`、`none`、`flex`。
